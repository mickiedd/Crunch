<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Behaviac Behavior Tree Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 280px;
            background: #252525;
            border-right: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        h2 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .tree-settings {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 5px;
        }

        .tree-settings input {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: #333;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 3px;
        }

        .tree-settings label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        .node-palette {
            margin-bottom: 25px;
        }

        .palette-item {
            padding: 10px;
            margin: 5px 0;
            background: #333;
            border-radius: 5px;
            cursor: grab;
            transition: background 0.2s;
            border-left: 3px solid;
        }

        .palette-item:hover {
            background: #404040;
        }

        .palette-item.Selector { border-color: #ff9800; }
        .palette-item.Sequence { border-color: #4caf50; }
        .palette-item.Parallel { border-color: #9c27b0; }
        .palette-item.Action { border-color: #2196f3; }
        .palette-item.Condition { border-color: #f44336; }
        .palette-item.Not { border-color: #00bcd4; }
        .palette-item.Loop { border-color: #ffeb3b; }
        .palette-item.AlwaysSuccess { border-color: #8bc34a; }
        .palette-item.AlwaysFailure { border-color: #e91e63; }

        .controls button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #4fc3f7;
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .controls button:hover {
            background: #81d4fa;
        }

        /* Canvas */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
            background-image:
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        #canvas {
            position: absolute;
            cursor: grab;
            transform-origin: 0 0;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .node {
            position: absolute;
            min-width: 200px;
            padding: 12px 15px;
            background: #333;
            border: 2px solid;
            border-radius: 8px;
            cursor: move;
            user-select: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .node:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.7);
        }

        .node.selected {
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.5);
        }

        .node.Selector { border-color: #ff9800; }
        .node.Sequence { border-color: #4caf50; }
        .node.Parallel { border-color: #9c27b0; }
        .node.Action { border-color: #2196f3; }
        .node.Condition { border-color: #f44336; }
        .node.Not { border-color: #00bcd4; }
        .node.Loop { border-color: #ffeb3b; }
        .node.AlwaysSuccess { border-color: #8bc34a; }
        .node.AlwaysFailure { border-color: #e91e63; }

        .node-header {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 11px;
            text-transform: uppercase;
            opacity: 0.7;
        }

        .node-field {
            margin: 5px 0;
        }

        .node-field label {
            font-size: 10px;
            color: #999;
            display: block;
            margin-bottom: 2px;
        }

        .node-field input, .node-field textarea {
            background: #444;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 4px 6px;
            width: 100%;
            border-radius: 3px;
            font-size: 12px;
            font-family: inherit;
            box-sizing: border-box;
        }

        .node-field textarea {
            resize: none;
            overflow: hidden;
            min-height: 22px;
            line-height: 1.4;
            display: block;
        }

        .connection-point {
            width: 12px;
            height: 12px;
            background: #4fc3f7;
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            z-index: 10;
        }

        .connection-point.input {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.output {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point:hover {
            background: #81d4fa;
            transform: translateX(-50%) scale(1.3);
        }

        svg {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        .connection-line {
            stroke: #4fc3f7;
            stroke-width: 2;
            fill: none;
        }

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #f44336;
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 11;
        }

        .node:hover .delete-btn {
            display: flex;
        }

        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h2>Tree Settings</h2>
            <div class="tree-settings">
                <label>Tree Name:</label>
                <input type="text" id="treeName" value="NewBehaviorTree" placeholder="Tree name">
                <label>Agent Type:</label>
                <input type="text" id="agentType" value="AIAgent" placeholder="Agent type">
                <label>Version:</label>
                <input type="text" id="version" value="5" placeholder="5">
            </div>

            <h2>Node Palette</h2>
            <div class="node-palette">
                <div class="palette-item Selector" draggable="true" data-type="Selector">
                    <strong>Selector</strong><br>
                    <small>First success wins (OR)</small>
                </div>
                <div class="palette-item Sequence" draggable="true" data-type="Sequence">
                    <strong>Sequence</strong><br>
                    <small>All must succeed (AND)</small>
                </div>
                <div class="palette-item Parallel" draggable="true" data-type="Parallel">
                    <strong>Parallel</strong><br>
                    <small>Run all simultaneously</small>
                </div>
                <div class="palette-item Action" draggable="true" data-type="Action">
                    <strong>Action</strong><br>
                    <small>Execute method</small>
                </div>
                <div class="palette-item Condition" draggable="true" data-type="Condition">
                    <strong>Condition</strong><br>
                    <small>Check boolean</small>
                </div>
                <div class="palette-item Not" draggable="true" data-type="Not">
                    <strong>Not (Inverter)</strong><br>
                    <small>Flip child result</small>
                </div>
                <div class="palette-item Loop" draggable="true" data-type="Loop">
                    <strong>Loop</strong><br>
                    <small>Repeat N times</small>
                </div>
                <div class="palette-item AlwaysSuccess" draggable="true" data-type="AlwaysSuccess">
                    <strong>Always Success</strong><br>
                    <small>Force success</small>
                </div>
                <div class="palette-item AlwaysFailure" draggable="true" data-type="AlwaysFailure">
                    <strong>Always Failure</strong><br>
                    <small>Force failure</small>
                </div>
            </div>

            <h2>Controls</h2>
            <div class="controls">
                <button onclick="app.exportXML()">üíæ Export XML</button>
                <button onclick="app.importXML()">üìÇ Import XML</button>
                <button onclick="app.saveJSON()">üíæ Save JSON (Layout)</button>
                <button onclick="app.loadJSON()">üìÇ Load JSON (Layout)</button>
                <button onclick="app.clearCanvas()">üóëÔ∏è Clear All</button>
            </div>
        </div>

        <div id="canvas-container">
            <svg id="connections"></svg>
            <div id="canvas"></div>
            <div id="info">
                <strong>Behaviac Editor</strong><br>
                Drag nodes | Connect ‚ö™‚Üí‚ö™ | Scroll=zoom | Drag canvas=pan
            </div>
        </div>
    </div>

    <script>
        const app = {
            nodes: [],
            connections: [],
            selectedNode: null,
            nextId: 1,
            canvas: null,
            container: null,
            svg: null,
            scale: 1,
            panX: 0,
            panY: 0,
            isDraggingCanvas: false,
            dragStartX: 0,
            dragStartY: 0,
            connectingFrom: null,
            tempLine: null,

            init() {
                this.canvas = document.getElementById('canvas');
                this.container = document.getElementById('canvas-container');
                this.svg = document.getElementById('connections');

                // Drag from palette
                document.querySelectorAll('.palette-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('nodeType', item.dataset.type);
                    });
                });

                // Drop on canvas
                this.container.addEventListener('dragover', (e) => e.preventDefault());
                this.container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const type = e.dataTransfer.getData('nodeType');
                    const rect = this.container.getBoundingClientRect();
                    const x = (e.clientX - rect.left - this.panX) / this.scale;
                    const y = (e.clientY - rect.top - this.panY) / this.scale;
                    this.createNode(type, x, y);
                });

                // Canvas panning
                this.container.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.button === 0 && e.target === this.container)) {
                        this.isDraggingCanvas = true;
                        this.dragStartX = e.clientX - this.panX;
                        this.dragStartY = e.clientY - this.panY;
                        e.preventDefault();
                    }
                });

                this.container.addEventListener('mousemove', (e) => {
                    if (this.isDraggingCanvas) {
                        this.panX = e.clientX - this.dragStartX;
                        this.panY = e.clientY - this.dragStartY;
                        this.updateCanvasTransform();
                    }
                    if (this.connectingFrom) {
                        this.updateTempLine(e);
                    }
                });

                this.container.addEventListener('mouseup', () => {
                    this.isDraggingCanvas = false;
                    if (this.tempLine) {
                        this.tempLine.remove();
                        this.tempLine = null;
                        this.connectingFrom = null;
                    }
                });

                // Zoom
                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.max(0.2, Math.min(3, this.scale * delta));

                    // Zoom towards the mouse cursor position
                    const rect = this.container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
                    this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
                    this.scale = newScale;

                    requestAnimationFrame(() => {
                        this.updateCanvasTransform();
                    });
                });

                // Click outside to deselect
                this.container.addEventListener('click', (e) => {
                    if (e.target === this.container) {
                        this.deselectAll();
                    }
                });

                this.updateCanvasTransform();
            },

            createNode(type, x, y) {
                const node = {
                    id: this.nextId++,
                    type,
                    x,
                    y,
                    comment: '',
                    method: '',
                    loopCount: -1,
                    children: []
                };

                this.nodes.push(node);
                this.renderNode(node);
                return node;
            },

            renderNode(node) {
                const el = document.createElement('div');
                el.className = `node ${node.type}`;
                el.dataset.id = node.id;
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';

                let fields = `
                    <div class="node-field">
                        <label>Comment:</label>
                        <textarea class="comment-field" placeholder="Describe this node" rows="1">${node.comment || ''}</textarea>
                    </div>
                `;

                if (node.type === 'Action' || node.type === 'Condition') {
                    fields += `
                        <div class="node-field">
                            <label>Method:</label>
                            <input type="text" class="method-field" value="${node.method || ''}" placeholder="MethodName">
                        </div>
                    `;
                }

                if (node.type === 'Loop') {
                    fields += `
                        <div class="node-field">
                            <label>Loop Count (-1=‚àû):</label>
                            <input type="number" class="loopcount-field" value="${node.loopCount || -1}">
                        </div>
                    `;
                }

                el.innerHTML = `
                    <div class="connection-point input" data-id="${node.id}"></div>
                    <div class="delete-btn">√ó</div>
                    <div class="node-header">${node.type}</div>
                    ${fields}
                    <div class="connection-point output" data-id="${node.id}"></div>
                `;

                // Node dragging
                let isDragging = false;
                let offsetX, offsetY;

                el.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (e.target.classList.contains('connection-point')) return;
                    if (e.target.classList.contains('delete-btn')) return;

                    isDragging = true;
                    const rect = el.getBoundingClientRect();
                    offsetX = (e.clientX - rect.left) / this.scale;
                    offsetY = (e.clientY - rect.top) / this.scale;
                    this.selectNode(node);
                    e.stopPropagation();
                });

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    const rect = this.container.getBoundingClientRect();
                    node.x = (e.clientX - rect.left - this.panX) / this.scale - offsetX;
                    node.y = (e.clientY - rect.top - this.panY) / this.scale - offsetY;
                    el.style.left = node.x + 'px';
                    el.style.top = node.y + 'px';
                    this.renderConnections();
                };

                const onMouseUp = () => {
                    isDragging = false;
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);

                // Field editing
                const commentField = el.querySelector('.comment-field');
                if (commentField) {
                    // Auto-resize textarea to fit content
                    const autoResize = (el) => {
                        el.style.height = 'auto';
                        el.style.height = el.scrollHeight + 'px';
                    };
                    autoResize(commentField);
                    commentField.addEventListener('input', (e) => {
                        node.comment = e.target.value;
                        autoResize(e.target);
                    });
                }

                const methodField = el.querySelector('.method-field');
                if (methodField) {
                    methodField.addEventListener('input', (e) => {
                        node.method = e.target.value;
                    });
                }

                const loopCountField = el.querySelector('.loopcount-field');
                if (loopCountField) {
                    loopCountField.addEventListener('input', (e) => {
                        node.loopCount = parseInt(e.target.value) || -1;
                    });
                }

                // Delete button
                el.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteNode(node);
                });

                // Connection points
                el.querySelector('.output').addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.startConnection(node);
                });

                el.querySelector('.input').addEventListener('mouseup', (e) => {
                    e.stopPropagation();
                    if (this.connectingFrom) {
                        this.createConnection(this.connectingFrom, node);
                        this.connectingFrom = null;
                        if (this.tempLine) {
                            this.tempLine.remove();
                            this.tempLine = null;
                        }
                    }
                });

                this.canvas.appendChild(el);
                return el;
            },

            startConnection(fromNode) {
                this.connectingFrom = fromNode;
            },

            updateTempLine(e) {
                if (!this.tempLine) {
                    this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    this.tempLine.classList.add('connection-line');
                    this.tempLine.style.opacity = '0.5';
                    this.svg.appendChild(this.tempLine);
                }

                const fromNode = this.connectingFrom;
                const fromEl = this.canvas.querySelector(`[data-id="${fromNode.id}"]`);
                if (!fromEl) return;

                const fromWidth = fromEl.offsetWidth;
                const fromHeight = fromEl.offsetHeight;

                // Start point: bottom center of node
                const x1 = fromNode.x + fromWidth / 2;
                const y1 = fromNode.y + fromHeight;

                // End point: mouse position in canvas space
                const containerRect = this.container.getBoundingClientRect();
                const x2 = (e.clientX - containerRect.left - this.panX) / this.scale;
                const y2 = (e.clientY - containerRect.top - this.panY) / this.scale;

                const midY = (y1 + y2) / 2;
                const d = `M ${x1},${y1} C ${x1},${midY} ${x2},${midY} ${x2},${y2}`;
                this.tempLine.setAttribute('d', d);
            },

            createConnection(fromNode, toNode) {
                if (fromNode === toNode) return;
                if (this.connections.find(c => c.from === fromNode && c.to === toNode)) return;

                this.connections.push({ from: fromNode, to: toNode });
                fromNode.children.push(toNode.id);
                this.renderConnections();
            },

            renderConnections() {
                this.svg.innerHTML = '';

                this.connections.forEach(conn => {
                    const fromNode = conn.from;
                    const toNode = conn.to;

                    if (!fromNode || !toNode) return;

                    // Get node widths from DOM
                    const fromEl = this.canvas.querySelector(`[data-id="${fromNode.id}"]`);
                    const toEl = this.canvas.querySelector(`[data-id="${toNode.id}"]`);
                    if (!fromEl || !toEl) return;

                    const fromWidth = fromEl.offsetWidth;
                    const fromHeight = fromEl.offsetHeight;
                    const toWidth = toEl.offsetWidth;
                    const toHeight = toEl.offsetHeight;

                    // Use canvas-space coordinates directly (node.x, node.y)
                    const x1 = fromNode.x + fromWidth / 2;
                    const y1 = fromNode.y + fromHeight;
                    const x2 = toNode.x + toWidth / 2;
                    const y2 = toNode.y;

                    const midY = (y1 + y2) / 2;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.classList.add('connection-line');
                    path.setAttribute('d', `M ${x1},${y1} C ${x1},${midY} ${x2},${midY} ${x2},${y2}`);
                    this.svg.appendChild(path);
                });
            },

            selectNode(node) {
                this.deselectAll();
                this.selectedNode = node;
                const el = this.canvas.querySelector(`[data-id="${node.id}"]`);
                if (el) el.classList.add('selected');
            },

            deselectAll() {
                this.canvas.querySelectorAll('.node').forEach(el => el.classList.remove('selected'));
                this.selectedNode = null;
            },

            deleteNode(node) {
                this.connections = this.connections.filter(c => c.from !== node && c.to !== node);
                this.nodes = this.nodes.filter(n => n !== node);
                this.nodes.forEach(n => {
                    n.children = n.children.filter(id => id !== node.id);
                });
                const el = this.canvas.querySelector(`[data-id="${node.id}"]`);
                if (el) el.remove();
                this.renderConnections();
            },

            updateCanvasTransform() {
                this.canvas.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
                this.svg.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
                this.renderConnections();
            },

            exportXML() {
                const treeName = document.getElementById('treeName').value || 'NewBehaviorTree';
                const agentType = document.getElementById('agentType').value || 'AIAgent';
                const version = document.getElementById('version').value || '5';

                const buildXMLNode = (nodeId, indent = '    ', visited = new Set()) => {
                    if (visited.has(nodeId)) return '';
                    visited.add(nodeId);

                    const node = this.nodes.find(n => n.id === nodeId);
                    if (!node) return '';

                    let xml = `${indent}<node class="${node.type}" id="${node.id}"`;
                    if (node.comment) {
                        xml += ` comment="${this.escapeXML(node.comment)}"`;
                    }
                    xml += '>\n';

                    // Add properties
                    if (node.type === 'Action' || node.type === 'Condition') {
                        if (node.method) {
                            xml += `${indent}    <property Method="${this.escapeXML(node.method)}" />\n`;
                        }
                    }

                    if (node.type === 'Loop' && node.loopCount !== undefined) {
                        xml += `${indent}    <property LoopCount="${node.loopCount}" />\n`;
                    }

                    // Add children
                    node.children.forEach(childId => {
                        xml += buildXMLNode(childId, indent + '    ', visited);
                    });

                    xml += `${indent}</node>\n`;
                    return xml;
                };

                // Find root nodes (nodes with no parents)
                const childIds = new Set(this.connections.map(c => c.to.id));
                const roots = this.nodes.filter(n => !childIds.has(n.id));

                if (roots.length === 0) {
                    alert('No root node found! Add nodes and connect them first.');
                    return;
                }

                let xml = `<?xml version="1.0" encoding="utf-8"?>\n`;
                xml += `<behavior name="${this.escapeXML(treeName)}" agenttype="${this.escapeXML(agentType)}" version="${version}">\n`;

                roots.forEach(root => {
                    xml += buildXMLNode(root.id);
                });

                xml += `</behavior>\n`;

                // Download
                const blob = new Blob([xml], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${treeName}.xml`;
                a.click();
                URL.revokeObjectURL(url);

                console.log('Exported XML:\n', xml);
            },

            escapeXML(str) {
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            },

            importXML() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'text/xml,application/xml';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const xmlText = event.target.result;
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                            // Check for parse errors
                            const parseError = xmlDoc.querySelector('parsererror');
                            if (parseError) {
                                throw new Error('XML parsing error: ' + parseError.textContent);
                            }

                            this.clearCanvas();

                            const behavior = xmlDoc.querySelector('behavior');
                            if (!behavior) {
                                throw new Error('No <behavior> root element found');
                            }

                            // Set tree properties
                            document.getElementById('treeName').value = behavior.getAttribute('name') || 'NewBehaviorTree';
                            document.getElementById('agentType').value = behavior.getAttribute('agenttype') || 'AIAgent';
                            document.getElementById('version').value = behavior.getAttribute('version') || '5';

                            // Parse nodes recursively
                            const nodeMap = {};
                            let yOffset = 100;

                            const parseXMLNode = (xmlNode, parentId = null, xOffset = 100) => {
                                const nodeClass = xmlNode.getAttribute('class');
                                const nodeId = parseInt(xmlNode.getAttribute('id')) || this.nextId;
                                const comment = xmlNode.getAttribute('comment') || '';

                                const node = this.createNode(nodeClass, xOffset, yOffset);
                                node.id = nodeId;
                                node.comment = comment;
                                this.nextId = Math.max(this.nextId, nodeId + 1);

                                // Parse properties
                                const properties = xmlNode.querySelectorAll(':scope > property');
                                properties.forEach(prop => {
                                    if (prop.hasAttribute('Method')) {
                                        node.method = prop.getAttribute('Method');
                                    }
                                    if (prop.hasAttribute('LoopCount')) {
                                        node.loopCount = parseInt(prop.getAttribute('LoopCount'));
                                    }
                                });

                                nodeMap[nodeId] = node;

                                // Update the rendered node
                                this.canvas.querySelector(`[data-id="${node.id}"]`).remove();
                                this.renderNode(node);

                                if (parentId !== null) {
                                    const parent = nodeMap[parentId];
                                    this.createConnection(parent, node);
                                }

                                // Parse children
                                const children = Array.from(xmlNode.children).filter(child => child.tagName === 'node');
                                yOffset += 120;
                                const childSpacing = 200;
                                const startX = xOffset - (children.length - 1) * childSpacing / 2;

                                children.forEach((childXML, idx) => {
                                    parseXMLNode(childXML, nodeId, startX + idx * childSpacing);
                                });
                            };

                            const rootNodes = Array.from(behavior.children).filter(child => child.tagName === 'node');
                            rootNodes.forEach((rootXML, idx) => {
                                yOffset = 100;
                                parseXMLNode(rootXML, null, 300 + idx * 400);
                            });

                            this.renderConnections();
                            alert('XML imported successfully!');
                        } catch (err) {
                            alert('Error importing XML: ' + err.message);
                            console.error(err);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },

            saveJSON() {
                const data = {
                    treeName: document.getElementById('treeName').value,
                    agentType: document.getElementById('agentType').value,
                    version: document.getElementById('version').value,
                    nodes: this.nodes.map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        comment: n.comment,
                        method: n.method,
                        loopCount: n.loopCount,
                        children: n.children
                    })),
                    connections: this.connections.map(c => ({
                        from: c.from.id,
                        to: c.to.id
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'behavior-tree-layout.json';
                a.click();
                URL.revokeObjectURL(url);
            },

            loadJSON() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.clearCanvas();

                            document.getElementById('treeName').value = data.treeName || 'NewBehaviorTree';
                            document.getElementById('agentType').value = data.agentType || 'AIAgent';
                            document.getElementById('version').value = data.version || '5';

                            const nodeMap = {};
                            data.nodes.forEach(nodeData => {
                                const node = {
                                    id: nodeData.id,
                                    type: nodeData.type,
                                    x: nodeData.x,
                                    y: nodeData.y,
                                    comment: nodeData.comment || '',
                                    method: nodeData.method || '',
                                    loopCount: nodeData.loopCount || -1,
                                    children: nodeData.children || []
                                };
                                this.nodes.push(node);
                                nodeMap[node.id] = node;
                                this.renderNode(node);
                                this.nextId = Math.max(this.nextId, node.id + 1);
                            });

                            data.connections.forEach(connData => {
                                const from = nodeMap[connData.from];
                                const to = nodeMap[connData.to];
                                if (from && to) {
                                    this.connections.push({ from, to });
                                }
                            });

                            this.renderConnections();
                            alert('JSON layout loaded!');
                        } catch (err) {
                            alert('Error loading file: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },

            clearCanvas() {
                this.nodes = [];
                this.connections = [];
                this.canvas.innerHTML = '';
                this.svg.innerHTML = '';
                this.selectedNode = null;
                this.nextId = 1;
            }
        };

        window.app = app;
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
